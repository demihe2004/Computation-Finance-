# 1. 
Greeks for Euro call

$$
\begin{align*}
\Delta_c &= \frac{C(S_0+\epsilon)-C(S_0-\epsilon)}{2\epsilon}\\
\Gamma_c &= \frac{C(S_0+\epsilon)-2C(S_0)+C(S_0-\epsilon)}{\epsilon^2}\\
\theta_c &= -\frac{C(T+dt)-C(T-dt)}{dt}\\
\mathcal v_c &= \frac{C(\sigma+\epsilon)-C(\sigma-\epsilon)}{2\epsilon}\\
\end{align*}
$$

``` python
def MC_euro_call_greeks(s0,T,x,r,sigma,epsilon):
    
    #delta
    s0_plus = s0 + epsilon
    s0_minus = s0 - epsilon
    delta = (MC_euro_call(s0_plus,T,x,r,sigma) - MC_euro_call(s0_minus,T,x,r,sigma))/(2*epsilon)

    #gamma
    gamma = ((MC_euro_call(s0_plus,T,x,r,sigma) - 2 * MC_euro_call(s0,T,x,r,sigma)) + (MC_euro_call(s0_minus,T,x,r,sigma)))/(epsilon**2)
    
    #theta
    T_plus = T + epsilon
    T_minus = T - epsilon
    theta = -(MC_euro_call(s0,T_plus,x,r,sigma) - MC_euro_call(s0,T_minus,x,r,sigma))/(2*epsilon)
    
    #vega
    sigma_plus = sigma + epsilon
    sigma_minus = sigma - epsilon
    vega = (MC_euro_call(s0,T,x,r,sigma_plus) - MC_euro_call(s0,T,x,r,sigma_minus))/(2*epsilon)
    
    return delta,gamma,theta,vega
```
# 2. 
Pricing call using Heston model
``` python 
def heston (rho,r,s0,v0,sigma,alpha,beta,simulation,step,method,k,T):
    # initiate st and vt array to hold results of simulations
    st = np.zeros(simulation)
    vt = np.zeros(simulation)
    
    # define f1, f2, f3 that takes in method arguement
    def f1(v, method):
        if method == "partial truncation" or method == "full truncation":
            v = v
        elif method == 'reflection':
            v = abs(v)
        else:
            return "error - no such method"
        return v

    def f2(v, method):
        if method == "partial truncation":
            v = v
        elif  method == "full truncation":
            v = max(0,v)
        elif method == 'reflection':
            v = abs(v)
        else:
            return "error - no such method"
        return v

    def f3(v, method):
        if method == "partial truncation" or method == "full truncation":
            v = max(0,v)
        elif method == 'reflection':
            v = abs(v)
        else:
            return "error - no such method"
        return v

    for _ in range(simulation):

        dt = T / step
        z1_step = np.random.normal(0, 1, step)
        z2_step = np.random.normal(0, 1, step)
        # set up z2 correlated with z1
        z2_step = rho * z1_step + np.sqrt(1 - rho ** 2) * z2_step

        st_i = 0
        vt_i = 0
        S0 = s0
        V0 = v0

        for z1,z2 in zip(z1_step,z2_step):
            st_i = S0 + r * S0 * dt + f3(V0, method = method) ** 0.5 * S0 * z1 * dt ** 0.5
            vt_i = f1 (V0 , method = method) + alpha * (beta - f2 (V0,method = method)) * dt + sigma * f3 (V0, method = method) ** 0.5 * z2 * dt ** 0.5

            S0 = st_i
            V0 = vt_i

        st[_] = S0
        vt[_] = V0
    
    payoff = np.maximum(st - k, 0)
    heston_call_price = np.exp(-r * T) * np.mean(payoff)
    
    return heston_call_price
```

# 3. 
2-dimensional Halton sequences
```python
def GetHalton(HowMany, Base):
    Seq = np.zeros(HowMany)
    NumBits = 1 + np.ceil(np.log(HowMany)/np.log(Base))
    VetBase = Base ** (-np.arange(1, NumBits + 1, 1))
    WorkVet = np.zeros(int(NumBits))
    
    for i in range(HowMany):
        j = 0
        ok = 0
        
        while ok == 0:
            WorkVet[j] += 1
            if WorkVet[j] < Base:
                ok = 1
            else:
                WorkVet[j] = 0
                j += 1
                
        Seq[i] = np.dot(WorkVet, VetBase)
        
    return Seq
```
![image](https://github.com/demihe2004/Computation-Finance-/assets/135466801/dd4ac125-aaef-4373-8236-04b2c083b64e)

- Halton generations are obviously more evenly distributed with in the [0,1] interval compared to Pseudo-Random numbers generated by LGM
- In the plot of 2-dimensional Halton sequences with base 2 and 4, two lines are overlapped since 4 is not a prime number and is dividable by 2 
- The sequence of base 4 have lots of same partition points as the line of base 2, but with larger variance. 
- In contrast, the sequence of 2 primes nubmers (2 and 7) does not have overlapping issue. Base 7 sequence have different partition points compared to base 2 sequence.  Base 7 sequence also have higher discrepancies with in the [0,1] interval.
